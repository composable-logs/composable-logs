import time
from typing import Set, Tuple, Dict, List

#
import pytest

#
import opentelemetry as ot

#
from pynb_dag_runner.opentelemetry_helpers import (
    get_span_id,
    has_keys,
    read_key,
    is_parent_child,
    get_duration_s,
    iso8601_to_epoch_s,
    get_duration_range_us,
    get_span_exceptions,
    Spans,
    SpanRecorder,
    DirectedGraph,
)
from pynb_dag_runner.helpers import one


def test_nested_dict_helpers():
    a_dict = {
        "a": {
            "b": 123,
            "foo": "bar",
            "bar": "baz",
            "c": {"e": 1, "f": 2, "g": "hello", "h": None},
        }
    }
    assert has_keys(a_dict, ["a"])
    assert has_keys(a_dict, ["a", "b"])
    assert not has_keys(a_dict, ["key-does-not-exist"])
    assert not has_keys(a_dict, ["key-does-not-exist", "key-does-not-exist"])
    assert not has_keys(a_dict, ["a", "key-does-not-exist"])

    assert read_key(a_dict, ["a", "b"]) == 123


def test_iso8601_to_epoch_s():
    assert iso8601_to_epoch_s("2021-10-10T10:25:35.173367Z") == 1633861535173367 / 1e6


def test_tracing_get_span_id_and_duration():
    # Example span generated by Ray when calling a remote method on an Actor
    test_span = {
        "name": "ActorA.foo ray.remote_worker",
        "context": {
            "trace_id": "<hex-trace-id>",
            "span_id": "<hex-span-id>",
            "trace_state": "[]",
        },
        "kind": "SpanKind.CONSUMER",
        "parent_id": "<hex-parent-id>",
        "start_time": "2021-10-10T10:25:35.173367Z",
        "end_time": "2021-10-11T10:25:46.173381Z",
        "status": {"status_code": "UNSET"},
        "attributes": {
            "ray.remote": "actor",
            "ray.actor_class": "ActorA",
            "ray.actor_method": "foo",
            "ray.function": "ActorA.foo",
            "ray.pid": "1234",
            "ray.job_id": "01000000",
            "ray.node_id": "<hex-ray-node-id>",
            "ray.actor_id": "<hex-ray-actor-id>",
            "ray.worker_id": "<hex-ray-worker-id>",
        },
        "events": [],
        "links": [],
        "resource": {
            "telemetry.sdk.language": "python",
            "telemetry.sdk.name": "opentelemetry",
            "telemetry.sdk.version": "1.5.0",
            "service.name": "unknown_service",
        },
    }

    assert get_span_id(test_span) == "<hex-span-id>"
    assert get_duration_s(test_span) == 86411.0000140667
    assert get_duration_range_us(test_span) == range(1633861535173367, 1633947946173381)
    assert get_span_exceptions(test_span) == []


# --- test Directed Graph functions ---


@pytest.fixture
def directed_tree_fixture() -> DirectedGraph[int]:
    """
    Test tree (a directed graph):

              0
              |
              1
            /   \
           2     3
         -----
        / | | \
       4  5 6  7
          |    |
          8    9
        / | \
      10 11  12
    """

    edges: Set[Tuple[int, int]] = {
        # (parent_id, child_id)
        (0, 1),
        #
        (1, 2),
        (1, 3),
        #
        (2, 4),
        (2, 5),
        (2, 6),
        (2, 7),
        #
        (5, 8),
        (7, 9),
        #
        (8, 10),
        (8, 11),
        (8, 12),
    }

    ts = DirectedGraph[int].from_edges(edges)
    assert set(ts.edges()) == edges
    return ts


def test__graph__from_edges(directed_tree_fixture: DirectedGraph[int]):
    assert directed_tree_fixture.all_node_ids == set(range(13))

    def get_child_ids(node_id: int) -> Set[int]:
        return set(
            child_id
            for (parent_id, child_id) in directed_tree_fixture.edges()
            if parent_id == node_id
        )

    expected_child_ids: Dict[int, List[int]] = {
        0: [1],
        1: [2, 3],
        2: [4, 5, 6, 7],
        3: [],
        4: [],
        5: [8],
        6: [],
        7: [9],
        8: [10, 11, 12],
        9: [],
        10: [],
        11: [],
        12: [],
    }

    for parent_id, child_ids in expected_child_ids.items():
        assert get_child_ids(node_id=parent_id) == set(child_ids)


def test__graph__can_create_empty_graph():
    assert len(DirectedGraph[int].from_edges(set([]))) == 0


def test__graph__built_in_methods(directed_tree_fixture: DirectedGraph[int]):
    assert len(directed_tree_fixture) == 13

    # iteration over nodes
    ts_list = list(iter(directed_tree_fixture))
    assert set(ts_list) == set(range(13))

    # test element membership in graph
    for node_id in range(13):
        assert node_id in directed_tree_fixture

    for no_node_id in [-1, "foo"]:
        assert not no_node_id in directed_tree_fixture


def test__graph__bound_inclusive(directed_tree_fixture: DirectedGraph[int]):
    # Bounding test-tree by node_id=0 (inclusive) should return the same tree
    tree_bound_0 = directed_tree_fixture.bound_inclusive(0)
    assert tree_bound_0 == directed_tree_fixture
    assert len(tree_bound_0) == len(directed_tree_fixture)

    # Bounding by other node_id:s should not return same tree
    assert not directed_tree_fixture == directed_tree_fixture.bound_inclusive(2)

    #
    # Bounding test-tree by node_id=5 (inclusive) should give tree
    #
    #      5
    #      |
    #      8
    #    / | \
    #  10 11  12
    #
    assert directed_tree_fixture.bound_inclusive(5).all_node_ids == {5, 8, 10, 11, 12}
    assert directed_tree_fixture.bound_inclusive(5) == DirectedGraph[int].from_edges(
        {
            (5, 8),
            #
            (8, 10),
            (8, 11),
            (8, 12),
        }
    )

    # Bounding test-tree by node_id=11 (inclusive) should give tree with only one
    # element.
    #
    # Note: this graph can not be generated from list of edges since there is only
    # one node.
    tree_bound_11 = directed_tree_fixture.bound_inclusive(11)
    assert tree_bound_11.all_node_ids == {11}
    assert tree_bound_11.edges() == set([])
    assert len(tree_bound_11) == 1


def test__graph__contains_path(directed_tree_fixture: DirectedGraph[int]):
    assert directed_tree_fixture.root_nodes() == set([0])

    assert directed_tree_fixture.contains_path(0, 1, 2, 4)
    assert directed_tree_fixture.contains_path(0, 4)
    assert directed_tree_fixture.contains_path(5, 8, 12)
    assert directed_tree_fixture.contains_path(5, 12)

    assert not directed_tree_fixture.contains_path(3, 7)
    assert not directed_tree_fixture.contains_path(2, 3)
    assert not directed_tree_fixture.contains_path(8, 9)
    assert not directed_tree_fixture.contains_path(3, 0)
